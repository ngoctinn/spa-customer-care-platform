# KẾ HOẠCH KỸ THUẬT: QUẢN LÝ LUỒNG KHÁCH HÀNG (CUSTOMER JOURNEY)

## 1. Mô tả Ngữ cảnh

Triển khai hệ thống quản lý khách hàng toàn diện với 3 luồng chính: Khách hàng vãng lai (Walk-in), Đăng ký online nhanh gọn (Lazy Registration), và Liên kết tài khoản cho khách hàng cũ (Account Linking). Hệ thống phân tách rõ ràng giữa bảng User (xác thực) và bảng Customer (hồ sơ CRM), cho phép một khách hàng có thể tồn tại mà không cần tài khoản online.

## 2. Các Tệp và Hàm Liên quan

### Tạo mới:

- **`src/modules/customers/models.py`:** Định nghĩa model Customer

  - Model `Customer(SQLModel, table=True)` với fields:
    - `id: int = Field(primary_key=True)`
    - `user_id: int | None = Field(foreign_key="user.id", nullable=True)` - Liên kết tài khoản (NULL nếu vãng lai)
    - `full_name: str | None` - Họ tên khách hàng (NULL nếu chưa cung cấp)
    - `phone_number: str | None` - Số điện thoại (NULL nếu chưa cung cấp)
    - `date_of_birth: date | None` - Ngày sinh
    - `gender: str | None` - Giới tính (M/F/Other)
    - `address: str | None` - Địa chỉ
    - `notes: str | None` - Ghi chú CRM
    - `skin_type: str | None` - Loại da
    - `health_conditions: str | None` - Tình trạng sức khỏe
    - `is_active: bool = True` - Trạng thái khách hàng
    - `created_at: datetime = Field(default_factory=datetime.utcnow)` - Ngày tạo
    - `updated_at: datetime = Field(default_factory=datetime.utcnow, sa_column_kwargs={"onupdate": datetime.utcnow})` - Ngày cập nhật
    - `deleted_at: datetime | None = Field(default=None)` - Ngày xoá mềm (Soft Delete, NULL = chưa xoá)

- **`src/modules/customers/schemas.py`:** Pydantic schemas

  - `CustomerCreateRequest` - Tạo khách hàng vãng lai (chỉ full_name, phone_number bắt buộc)
  - `CustomerUpdateRequest` - Cập nhật thông tin khách hàng (full_name, phone_number, email, v.v.)
  - `CustomerLinkRequest` - Liên kết tài khoản (phone_number bắt buộc)
  - `CustomerVerifyOTPRequest` - Xác minh OTP (otp_code bắt buộc)
  - `CustomerResponse` - Response khách hàng (tất cả fields)
  - `CustomerListResponse` - Response danh sách khách hàng

- **`src/modules/customers/crud.py`:** Hàm CRUD

  - `create_customer(session: Session, full_name: str | None, phone_number: str | None, user_id: int | None = None) -> Customer` - Tạo khách hàng mới
  - `get_customer_by_id(session: Session, customer_id: int, include_deleted: bool = False) -> Customer | None` - Lấy khách hàng theo ID (mặc định bỏ qua deleted)
  - `get_customer_by_user_id(session: Session, user_id: int, include_deleted: bool = False) -> Customer | None` - Lấy khách hàng theo user_id (mặc định bỏ qua deleted)
  - `get_customer_by_phone_number(session: Session, phone_number: str, include_deleted: bool = False) -> Customer | None` - Lấy khách hàng theo SĐT (mặc định bỏ qua deleted)
  - `get_customer_by_phone_and_no_user(session: Session, phone_number: str) -> Customer | None` - Lấy khách hàng cũ (có SĐT nhưng user_id NULL, bỏ qua deleted)
  - `update_customer(session: Session, customer_id: int, data: dict) -> Customer | None` - Cập nhật khách hàng (chỉ nếu chưa bị xoá)
  - `soft_delete_customer(session: Session, customer_id: int) -> bool` - Xóa mềm khách hàng (SET deleted_at = now())
  - `restore_customer(session: Session, customer_id: int) -> bool` - Khôi phục khách hàng đã bị xoá (SET deleted_at = NULL)
  - `find_customer_by_query(session: Session, query: str, include_deleted: bool = False) -> List[Customer]` - Tìm kiếm khách hàng theo tên hoặc SĐT (mặc định bỏ qua deleted)
  - `link_customer_with_user(session: Session, customer_id: int, user_id: int) -> Customer` - Liên kết khách hàng với user
  - `unlink_customer_from_user(session: Session, customer_id: int) -> Customer` - Hủy liên kết khách hàng

- **`src/modules/customers/service.py`:** Logic nghiệp vụ

  - `create_walk_in_customer(full_name: str, phone_number: str) -> dict` - Tạo khách hàng vãng lai
  - `create_online_customer_with_user(user_id: int, phone_number: str | None = None, full_name: str | None = None) -> dict` - Tạo hồ sơ Customer cho user mới (lazy registration)
  - `complete_customer_profile(user_id: int, full_name: str, phone_number: str) -> dict` - Hoàn thiện hồ sơ CRM khi đặt lịch
  - `initiate_account_linking(user_id: int, phone_number: str) -> dict` - Bắt đầu luồng liên kết (gửi OTP)
  - `verify_otp_and_link_account(user_id: int, phone_number: str, otp_code: str) -> dict` - Xác minh OTP và hợp nhất hồ sơ
  - `delete_customer(customer_id: int) -> dict` - Xóa mềm khách hàng (soft delete) - chi tiết xem tại mục 3.8
  - `restore_customer(customer_id: int) -> dict` - Khôi phục khách hàng đã bị xoá
  - `search_customers(query: str, skip: int = 0, limit: int = 50, include_deleted: bool = False) -> List[dict]` - Tìm kiếm khách hàng

- **`src/modules/customers/router.py`:** APIRouter

  - `POST /customers/walk-in` - Tạo khách hàng vãng lai (Lễ tân)
  - `POST /customers/profile` - Tạo/hoàn thiện hồ sơ CRM (User đã đăng nhập)
  - `GET /customers/{customer_id}` - Lấy thông tin khách hàng (không trả dữ liệu đã xoá)
  - `PUT /customers/{customer_id}` - Cập nhật thông tin khách hàng (không update record đã xoá)
  - `DELETE /customers/{customer_id}` - Xóa mềm khách hàng (Lễ tân/Admin) - chi tiết xem tại mục 3.8
  - `POST /customers/{customer_id}/restore` - Khôi phục khách hàng đã bị xoá (Admin)
  - `GET /customers/search` - Tìm kiếm khách hàng (query: str, mặc định bỏ qua deleted)
  - `POST /customers/link-account/initiate` - Bắt đầu liên kết tài khoản (User đã đăng nhập + SĐT)
  - `POST /customers/link-account/verify` - Xác minh OTP và hoàn tất liên kết (User đã đăng nhập + OTP)
  - `GET /customers/me` - Lấy hồ sơ khách hàng của user hiện tại

- **`src/core/otp.py`:** Module quản lý OTP (nếu chưa có)
  - Hàm `generate_otp(length: int = 6) -> str` - Tạo OTP ngẫu nhiên
  - Hàm `send_otp_sms(phone_number: str, otp_code: str) -> bool` - Gửi OTP qua SMS (hoặc fallback callback)
  - Hàm `store_otp(phone_number: str, otp_code: str, expires_in_minutes: int = 5) -> None` - Lưu OTP vào cache (Redis hoặc in-memory)
  - Hàm `verify_otp(phone_number: str, otp_code: str) -> bool` - Xác minh OTP
  - Hàm `clear_otp(phone_number: str) -> None` - Xóa OTP sau khi dùng

### Sửa đổi:

- **`src/modules/auth/models.py`:**

  - Model `User` - Thêm field `customer: Customer | None = None` (back-reference nếu dùng relationship)
  - Hoặc giữ nguyên, không cần back-reference vì Customer đã có foreign key

- **`src/modules/auth/schemas.py`:**

  - Schema `RegisterRequest` - Thêm field tùy chọn: `phone_number: str | None`, `full_name: str | None`

- **`src/modules/auth/service.py`:**

  - Hàm `register_user(email: str, password: str, phone_number: str | None = None, full_name: str | None = None) -> dict`
    - Gọi hàm tạo user (giữ nguyên logic cũ)
    - Gọi `create_online_customer_with_user(user_id, phone_number, full_name)` để tạo hồ sơ Customer đi kèm

- **`src/modules/auth/router.py`:**

  - Endpoint `POST /auth/register` - Nhận thêm fields: `phone_number`, `full_name` (tùy chọn)
  - Gọi service đã sửa đổi

- **`src/main.py`:**
  - Gắn `customers_router` vào app

## 3. Thuật toán/Logic (Từng bước)

### 3.1 Luồng 1: Khách Hàng Vãng Lai (Walk-in)

**Bước 1: Lễ tân tạo khách hàng vãng lai**

1. POST `/customers/walk-in` với body:
   ```json
   {
     "full_name": "Chị An",
     "phone_number": "0912345678"
   }
   ```
2. Backend gọi `create_walk_in_customer(full_name, phone_number)`:
   - Validate dữ liệu (full_name và phone_number bắt buộc)
   - Kiểm tra phone_number chưa tồn tại (tùy policy)
   - Gọi `create_customer(full_name=full_name, phone_number=phone_number, user_id=None)`
   - Lưu vào DB: Customer(full_name="Chị An", phone_number="0912345678", user_id=NULL, ...)
   - Return customer record
3. Trả response `{"id": 123, "full_name": "Chị An", "phone_number": "0912345678", "user_id": null, ...}`

---

### 3.2 Luồng 2a: Đăng ký Online Nhanh Gọn (Lazy Registration)

**Bước 1: User đăng ký chỉ với email và password**

1. POST `/auth/register` với body:
   ```json
   {
     "email": "binh@example.com",
     "password": "SecurePass123!"
   }
   ```
2. Backend gọi `register_user(email, password, phone_number=None, full_name=None)`:
   - Validate email (không trùng, format đúng)
   - Validate password (độ mạnh)
   - Hash password
   - **Transaction bắt đầu:**
     - Tạo User: `User(email="binh@example.com", password_hash=..., is_active=False, ...)`
     - Gọi `create_online_customer_with_user(user_id, None, None)`:
       - Tạo Customer: `Customer(user_id=user_id, full_name=NULL, phone_number=NULL, is_active=True)`
     - Tạo email verification token (trong bảng VerificationToken hoặc tương tự)
     - Gửi email xác minh
   - **Transaction commit**
   - Return `{"message": "Đăng ký thành công. Vui lòng xác minh email"}`
3. Trả response HTTP 201

**Bước 2: User xác minh email và đăng nhập**

1. User click link xác minh email (tuỳ theo 0002_PLAN)
2. POST `/auth/login` với email và password
3. Backend xác thực, tạo JWT, trả access_token
4. User đăng nhập thành công, hồ sơ Customer vẫn chỉ có `user_id` (full_name, phone_number = NULL)

---

### 3.3 Luồng 2b: Hoàn Thiện Hồ Sơ Khi Đặt Lịch

**Bước 1: User truy cập trang đặt lịch**

1. GET `/appointments/create` (require JWT authentication)
2. Backend:
   - Lấy user_id từ JWT (via `get_current_user` dependency)
   - Query `get_customer_by_user_id(user_id)`
   - Kiểm tra customer.full_name IS NULL hoặc customer.phone_number IS NULL
   - Nếu thiếu, frontend hiển thị form yêu cầu: "Để hoàn tất đặt lịch, vui lòng cung cấp Họ Tên và Số Điện Thoại"

**Bước 2: User cung cấp thông tin còn thiếu**

1. POST `/customers/profile` với body:
   ```json
   {
     "full_name": "Anh Bình",
     "phone_number": "0987654321"
   }
   ```
2. Backend (require JWT):
   - Lấy user_id từ JWT
   - Query `get_customer_by_user_id(user_id)` để lấy customer record hiện tại
   - Validate full_name và phone_number
   - Gọi `update_customer(customer_id, {"full_name": full_name, "phone_number": phone_number})`
   - Lưu vào DB, update `updated_at`
   - Return updated customer record
3. Trả response `{"id": 456, "user_id": 789, "full_name": "Anh Bình", "phone_number": "0987654321", ...}`

**Bước 3: User tiếp tục đặt lịch hẹn**

1. Hồ sơ Customer đã hoàn thiện, có thể tiếp tục quy trình đặt lịch hẹn bình thường

---

### 3.4 Luồng 3a: Khách Hàng Cũ Đăng Ký Tài Khoản Online

**Bước 1: User đăng ký như Luồng 2a**

1. Giống Luồng 2a hoàn toàn
2. Kết quả: Tạo ra một cặp User mới + Customer "chờ" (stub) mới

---

### 3.5 Luồng 3b: Kích Hoạt Luồng Liên Kết (Account Linking)

**Bước 1: User đăng nhập và truy cập trang quản lý tài khoản**

1. User đã đăng nhập (có JWT valid)
2. GET `/customers/me` hoặc GET `/accounts/profile` (require JWT)
3. Backend:
   - Lấy user_id từ JWT
   - Query `get_customer_by_user_id(user_id)` để lấy hồ sơ Customer "chờ"
   - Kiểm tra customer.full_name IS NULL AND customer.phone_number IS NULL
   - Nếu đúng, frontend hiển thị khu vực nổi bật: **"Bạn là khách hàng thân thiết của chúng tôi? Liên kết ngay để xem lại toàn bộ lịch sử điều trị!"** + nút "Liên kết"

**Bước 2: User click nút "Liên kết" và nhập SĐT**

1. Frontend hiển thị form: "Nhập Số Điện Thoại bạn đã dùng tại spa"
2. User nhập: `"0912345678"`
3. POST `/customers/link-account/initiate` với body:
   ```json
   {
     "phone_number": "0912345678"
   }
   ```

---

### 3.6 Luồng 3c: Xác Minh và Gửi OTP

**Bước 1: Backend xác minh SĐT**

1. Backend (require JWT):
   - Lấy user_id từ JWT
   - Validate phone_number format
   - Query `get_customer_by_phone_and_no_user(phone_number)` để tìm hồ sơ cũ
   - Kiểm tra: `customer.user_id IS NULL` (hồ sơ chưa liên kết)
   - Nếu không tìm thấy: Return error 404 `{"error": "Không tìm thấy hồ sơ khách hàng cũ với SĐT này"}`

**Bước 2: Gửi OTP**

1. Backend (tiếp tục):
   - Gọi `generate_otp(length=6)` để tạo OTP (vd: "123456")
   - Gọi `send_otp_sms(phone_number, otp_code)`:
     - Nếu có SMS service (Twilio, v.v.): Gửi SMS thật
     - Nếu không: Log OTP hoặc callback webhook (dev mode)
   - Gọi `store_otp(phone_number, otp_code, expires_in_minutes=5)`:
     - Lưu vào Redis hoặc in-memory cache (tuỳ infrastructure)
     - Lưu mapping: `"otp:{phone_number}" -> otp_code` với TTL 5 phút
   - Return response: `{"message": "OTP đã được gửi đến 0912345678"}`

---

### 3.7 Luồng 3d: Hoàn Tất Hợp Nhất (Verify OTP & Link)

**Bước 1: User nhập OTP và submit**

1. User nhập OTP: `"123456"`
2. POST `/customers/link-account/verify` với body:
   ```json
   {
     "phone_number": "0912345678",
     "otp_code": "123456"
   }
   ```

**Bước 2: Backend xác minh OTP**

1. Backend (require JWT):
   - Lấy user_id từ JWT
   - Gọi `verify_otp(phone_number, otp_code)`:
     - Query cache: `"otp:{phone_number}"`
     - So sánh otp_code
     - Nếu khớp: Return True, nếu không: Return False
   - Nếu OTP sai: Return error 400 `{"error": "OTP không đúng hoặc đã hết hạn"}`

**Bước 3: Hợp Nhất Hồ Sơ (Transaction)**

1. **Transaction bắt đầu:**

   - **Bước 3.1 - Tìm đối tượng:**

     - Lấy `user_id` từ JWT (tài khoản mới đang đăng nhập)
     - Query `get_customer_by_user_id(user_id)` -> `old_stub_customer` (hồ sơ "chờ" rỗng)
     - Query `get_customer_by_phone_and_no_user(phone_number)` -> `old_real_customer` (hồ sơ cũ đầy đủ)

   - **Bước 3.2 - Cập nhật hồ sơ cũ:**

     - UPDATE bảng Customer:
       ```sql
       UPDATE customer
       SET user_id = :user_id, updated_at = now()
       WHERE id = :old_real_customer.id
       ```
     - Hồ sơ cũ giờ đã liên kết với user_id mới

   - **Bước 3.3 - Xóa hồ sơ "chờ":**
     - DELETE từ bảng Customer:
       ```sql
       DELETE FROM customer WHERE id = :old_stub_customer.id
       ```
     - Tránh dư thừa dữ liệu

2. **Transaction commit**

**Bước 4: Return Response**

1. Trả response:
   ```json
   {
     "message": "Liên kết tài khoản thành công!",
     "customer": {
       "id": 123,
       "user_id": 789,
       "full_name": "Chị Chi",
       "phone_number": "0912345678",
       "created_at": "2025-10-15T10:00:00",
       ...
     }
   }
   ```

**Bước 5: Dọn Dẹp OTP**

1. Backend:
   - Gọi `clear_otp(phone_number)` để xóa OTP khỏi cache
   - (Optional) Log thành công liên kết tài khoản cho audit

**Bước 6: User Đăng Xuất & Đăng Nhập Lại**

1. User đăng xuất
2. User đăng nhập lại bằng email của tài khoản mới
3. Hệ thống query `get_customer_by_user_id(user_id)` trả về hồ sơ cũ đầy đủ (bao gồm toàn bộ lịch sử điều trị)
4. User nhìn thấy toàn bộ quá trình điều trị của chị Chi

---

### 3.8 Luồng Xóa Mềm Khách Hàng (Soft Delete)

**⚠️ QUAN TRỌNG:** Sử dụng **Xóa Mềm (Soft Delete)** thay vì Xóa Cứng (Hard Delete) để:

- Bảo vệ tính toàn vẹn dữ liệu lịch sử điều trị
- Cho phép audit trail
- Hỗ trợ khôi phục dữ liệu
- Tuân thủ quy định quản lý y tế

**Bước 1: Lễ tân / Admin yêu cầu xóa khách hàng**

1. DELETE `/customers/{customer_id}` (require Lễ tân/Admin role)
2. Backend:
   - Lấy customer_id từ URL path
   - Validate customer tồn tại và chưa bị xoá (deleted_at IS NULL)
   - Nếu không tìm thấy: Return error 404

**Bước 2: Kiểm Tra Ràng Buộc (Optional nhưng Khuyến Nghị)**

1. Query bảng liên quan (appointments, invoices, v.v.):
   - Nếu khách hàng có lịch hẹn tương lai: Khuyến cáo hủy/cập nhật trước khi xoá
   - Nếu khách hàng có số dư nợ: Khuyến cáo thanh toán trước khi xoá
   - Cho phép xóa mềm ngay cả khi có liên kết (do dữ liệu lịch sử quan trọng)

**Bước 3: Thực Hiện Xóa Mềm**

1. Backend gọi `soft_delete_customer(customer_id)`:

   - UPDATE bảng Customer:
     ```sql
     UPDATE customer
     SET deleted_at = now(), updated_at = now()
     WHERE id = :customer_id
     ```
   - Không xóa bất kỳ dòng nào từ DB
   - Giữ lại toàn bộ dữ liệu lịch sử

2. Return response:
   ```json
   {
     "message": "Khách hàng đã bị xóa (soft delete)",
     "customer_id": 123,
     "deleted_at": "2025-10-16T15:30:00",
     "can_restore": true
   }
   ```

**Bước 4: Tác Động Đến Các Query Khác**

Tất cả các GET/search query sau khi này phải **tự động bỏ qua khách hàng đã xoá**:

```python
# Ví dụ query trong get_customer_by_id:
SELECT * FROM customer
WHERE id = :id
AND deleted_at IS NULL  # ← Luôn thêm filter này

# Ví dụ query tìm kiếm:
SELECT * FROM customer
WHERE (full_name LIKE :query OR phone_number LIKE :query)
AND deleted_at IS NULL  # ← Luôn thêm filter này
```

---

### 3.9 Luồng Khôi Phục Khách Hàng (Restore)

**Bước 1: Admin yêu cầu khôi phục khách hàng đã bị xoá**

1. POST `/customers/{customer_id}/restore` (require Admin role)
2. Backend:
   - Lấy customer_id từ URL path
   - Validate customer tồn tại và đã bị xoá (deleted_at IS NOT NULL)
   - Nếu không tìm thấy: Return error 404

**Bước 2: Thực Hiện Khôi Phục**

1. Backend gọi `restore_customer(customer_id)`:

   - UPDATE bảng Customer:
     ```sql
     UPDATE customer
     SET deleted_at = NULL, updated_at = now()
     WHERE id = :customer_id
     ```

2. Return response:
   ```json
   {
     "message": "Khách hàng đã được khôi phục",
     "customer": {
       "id": 123,
       "full_name": "Chị An",
       "phone_number": "0912345678",
       "deleted_at": null,
       ...
     }
   }
   ```

---

## 4. Các Bảng Database Liên quan

### Bảng `customer` (SQLModel)

| Cột                 | Kiểu        | Nullable | Constraint                | Mô Tả                                                   |
| ------------------- | ----------- | -------- | ------------------------- | ------------------------------------------------------- |
| `id`                | Integer     | NO       | PRIMARY KEY               | ID khách hàng                                           |
| `user_id`           | Integer     | YES      | FOREIGN KEY -> user(id)   | ID tài khoản (nếu có)                                   |
| `full_name`         | String(255) | YES      |                           | Họ tên khách hàng                                       |
| `phone_number`      | String(20)  | YES      | UNIQUE                    | Số điện thoại                                           |
| `date_of_birth`     | Date        | YES      |                           | Ngày sinh                                               |
| `gender`            | String(10)  | YES      |                           | Giới tính                                               |
| `address`           | Text        | YES      |                           | Địa chỉ                                                 |
| `notes`             | Text        | YES      |                           | Ghi chú CRM                                             |
| `skin_type`         | String(50)  | YES      |                           | Loại da                                                 |
| `health_conditions` | Text        | YES      |                           | Tình trạng sức khỏe                                     |
| `is_active`         | Boolean     | NO       | DEFAULT TRUE              | Trạng thái                                              |
| `created_at`        | DateTime    | NO       | DEFAULT CURRENT_TIMESTAMP | Ngày tạo                                                |
| `updated_at`        | DateTime    | NO       | DEFAULT CURRENT_TIMESTAMP | Ngày cập nhật                                           |
| `deleted_at`        | DateTime    | YES      | DEFAULT NULL              | **Ngày xoá mềm (NULL = chưa xoá, có giá trị = đã xoá)** |

### Bảng `user` (sửa đổi nhỏ)

Thêm field (nếu chưa có):

- `customer_id` (Optional, nếu muốn back-reference từ User -> Customer)

Hoặc giữ nguyên, vì Customer đã có foreign key -> User

---

## 5. Dependencies & Decorators

### Dependencies cần sửa đổi/thêm:

- **`get_current_user`** (đã có) - Lấy User từ JWT
- **`get_customer_or_none`** (mới) - Dependency tùy chọn để lấy Customer liên kết, nếu không có trả None
  ```python
  async def get_customer_or_none(current_user: User = Depends(get_current_user)) -> Customer | None:
      # Query customer by user_id
      # Return customer hoặc None
  ```

### Decorators/Middleware cần:

- Kiểm tra JWT trong các endpoint protected (đã có từ 0001_PLAN)
- Logging cho các thao tác sensitive (liên kết tài khoản, xóa khách hàng)

---

## 6. Validation & Error Handling

### Validation Rules:

- **phone_number**: Format Việt Nam (0xxx xxx xxxx hoặc +84xxx xxx xxxx), không trùng lặp (tuỳ policy)
- **full_name**: Không rỗng, tối đa 255 ký tự
- **email**: Email format hợp lệ (tuỳ từ User)
- **OTP**: Đúng 6 ký tự, chưa hết hạn (< 5 phút)

### Error Responses:

- `400 Bad Request` - Dữ liệu không hợp lệ
- `404 Not Found` - Khách hàng / Hồ sơ cũ không tìm thấy
- `409 Conflict` - Phone number đã tồn tại
- `401 Unauthorized` - JWT không hợp lệ (trong authenticated endpoints)
- `500 Internal Server Error` - Lỗi server (OTP gửi thất bại, v.v.)

---

## 7. Notes & Considerations

1. **Soft Delete (Xóa Mềm) - BẮT BUỘC:**

   - Tất cả xóa khách hàng phải dùng xóa mềm (SET deleted_at = now()), **KHÔNG xóa cứng (DELETE)**
   - Lý do: Bảo vệ dữ liệu lịch sử, tuân thủ pháp lý, hỗ trợ audit trail
   - Cần thêm filter `deleted_at IS NULL` vào tất cả query GET/search

2. **Hard Delete (Xóa Cứng) - NGHIÊM CẤM:**

   - Không được dùng DELETE statement trực tiếp trên bảng Customer
   - Nếu thực sự cần xóa hoàn toàn (ít khi xảy ra), phải:
     - Lưu backup dữ liệu trước
     - Có approval từ quản lý
     - Log chi tiết vào audit table

3. **Transaction Safety:** Luồng 3 (hợp nhất hồ sơ) phải chạy trong transaction để đảm bảo consistency.

4. **OTP Management:** Nên dùng Redis hoặc cache backend khác cho performance, không nên dùng DB.

5. **SMS Service:** Nếu không có SMS service, có thể:

   - Log OTP vào console (dev mode)
   - Gửi OTP qua email thay vì SMS (fallback)
   - Cung cấp API callback webhook (test mode)

6. **Duplicate Handling:** Nên có strategy rõ ràng khi user liên kết với nhiều hồ sơ cũ (reject hoặc cho phép lựa chọn).

7. **Query Performance:** Nên thêm **index** trên các cột thường xuyên query:

   - `user_id`
   - `phone_number`
   - `deleted_at` (để tối ưu filter soft delete)

8. **Migration:** Cần viết Alembic migration để:

   - Tạo bảng Customer
   - Thêm cột `deleted_at` vào Customer (với default NULL)
   - Tạo index trên user_id, phone_number, deleted_at
   - Cập nhật User table (nếu cần)

9. **Testing:** Cần unit test cho các hàm service:

   - Create walk-in customer
   - Lazy registration + profile completion
   - Account linking (initiate + verify + merge)
   - Soft delete + restore
   - Integration test cho tất cả endpoints

10. **Search Query Optimization:**
    - Khi search với `deleted_at IS NULL`, cần đảm bảo index được sử dụng
    - Cân nhắc thêm covering index hoặc composite index nếu có query phức tạp
